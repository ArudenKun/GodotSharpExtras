using System;
using System.Linq;
using System.Text;
using GodotSharpExtras.SourceGenerators.Extensions;
using Microsoft.CodeAnalysis;

namespace GodotSharpExtras.SourceGenerators.Utilities;

internal sealed class SourceStringBuilder
{
    public const string TopMessage = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        """;

    public const string BottomMessage = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     Roslyn doesn't clear the file when writing debug output for
        //     EmitCompilerGeneratedFiles, so I'm writing this message to
        //     make it more obvious what's going on when that happens.
        // </auto-generated>
        //------------------------------------------------------------------------------
        """;

    private readonly StringBuilder _indentPrefix = new();
    private readonly StringBuilder _sourceBuilder = new();
    private readonly INamedTypeSymbol _typeSymbol;

    public SourceStringBuilder(IPropertySymbol propertySymbol)
    {
        _sourceBuilder.AppendLine(TopMessage);
        _typeSymbol = propertySymbol.ContainingType;
    }

    public SourceStringBuilder(IFieldSymbol fieldSymbol)
    {
        _sourceBuilder.AppendLine(TopMessage);
        _typeSymbol = fieldSymbol.ContainingType;
    }

    public SourceStringBuilder(INamedTypeSymbol typeSymbol)
    {
        _sourceBuilder.AppendLine(TopMessage);
        _typeSymbol = typeSymbol;
    }

    public SourceStringBuilder(IMethodSymbol methodSymbol)
    {
        _sourceBuilder.AppendLine(TopMessage);
        _typeSymbol = methodSymbol.ContainingType;
    }

    public void Line(params string[] parts)
    {
        if (parts.Length != 0)
        {
            _sourceBuilder.Append(_indentPrefix);

            foreach (var s in parts)
                _sourceBuilder.Append(s);
        }

        _sourceBuilder.AppendLine();
    }

    public void Line(string line)
    {
        Line(parts: line);
    }

    public void BlockTab(Action writeInner)
    {
        BlockPrefix("\t", writeInner);
    }

    public void BlockPrefix(string delimiter, Action writeInner)
    {
        _indentPrefix.Append(delimiter);
        writeInner();
        _indentPrefix.Remove(_indentPrefix.Length - delimiter.Length, delimiter.Length);
    }

    public void BlockBrace(Action writeInner)
    {
        Line("{");
        BlockTab(writeInner);
        Line("}");
    }

    public void BlockDecl(Action writeInner, string suffix = ";")
    {
        Line("{");
        BlockTab(writeInner);
        Line($"}}{suffix}");
    }

    public void NamespaceBlockBrace(Action writeInner)
    {
        Line("namespace ", _typeSymbol.NamespaceOrEmpty());
        BlockBrace(writeInner);
    }

    public void NamespaceBlockBraceIfExists(string? ns, Action writeInner)
    {
        if (ns is { Length: > 0 })
        {
            Line("namespace ", ns);
            BlockBrace(writeInner);
        }
        else
        {
            BlockPrefix("", writeInner);
        }
    }

    public void PartialTypeBlockBrace(Action writeInner)
    {
        var type =
            _typeSymbol.IsRecord ? "record"
            : _typeSymbol.IsValueType ? "struct"
            : "class";
        NamespaceBlockBrace(() =>
        {
            Line($"partial {type} {_typeSymbol.Name}");
            if (_typeSymbol.IsGenericType)
            {
                BlockTab(() =>
                {
                    Line(
                        "<",
                        string.Join(
                            ", ",
                            _typeSymbol.TypeParameters.Select(p => p.ToFullDisplayString())
                        ),
                        ">"
                    );
                });
            }

            BlockBrace(writeInner);
        });
    }

    public void PartialTypeBlockBrace(string baseClassesOrImplementations, Action writeInner)
    {
        var type =
            _typeSymbol.IsRecord ? "record"
            : _typeSymbol.IsValueType ? "struct"
            : "class";

        NamespaceBlockBrace(() =>
        {
            Line($"partial {type} {_typeSymbol.Name} : {baseClassesOrImplementations}");
            Line($"partial {type} {_typeSymbol.Name}");
            if (_typeSymbol.IsGenericType)
            {
                BlockTab(() =>
                {
                    Line(
                        "<",
                        string.Join(
                            ", ",
                            _typeSymbol.TypeParameters.Select(p => p.ToFullDisplayString())
                        ),
                        ">"
                    );
                });
            }

            BlockBrace(writeInner);
        });
    }

    public void Constructor(string args, Action writeInner)
    {
        Line($"public {_typeSymbol.Name}({args})");
        BlockBrace(writeInner);
    }

    public void Constructor(Action writeInner)
    {
        Line($"public {_typeSymbol.Name}()");
        BlockBrace(writeInner);
    }

    public void StaticConstructor(Action writeInner)
    {
        Line($"static {_typeSymbol.Name}()");
        BlockBrace(writeInner);
    }

    public override string ToString()
    {
        return _sourceBuilder.AppendLine(BottomMessage).ToString();
    }
}
